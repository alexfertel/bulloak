//! Noir test code generation.

use anyhow::Result;
use bulloak_syntax::Ast;

use crate::config::Config;
use crate::test_structure::Root;
use crate::scaffold::scaffoldable::Scaffoldable;

/// Generate Noir test code from an AST.
///
/// # Errors
///
/// Returns an error if code generation fails.
pub(super) fn generate(forest: &Vec<Ast>, cfg: &Config) -> Result<String> {
    let root = Root::new(forest);

    Ok(root.scaffold(!cfg.skip_setup_hooks))
}

#[cfg(test)]
mod tests {
    use bulloak_syntax::parse;
    use pretty_assertions::assert_str_eq;

    use super::*;

    #[test]
    fn test_generate_basic() {
        let tree = r"
hash_pair
├── It should always work.
└── When first arg is smaller
    └── It should match result.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("// Generated by bulloak"));
        // do not generate helpers for trivial levels of nesting
        assert!(!output.contains("fn first_arg_is_smaller()"));
        assert!(!output.contains("    when_first_arg_is_smaller()"));
        assert!(output
            .contains("#[test]\nunconstrained fn test_should_always_work()"));
        assert!(output.contains(
            "#[test]\nunconstrained fn test_when_first_arg_is_smaller()"
        ));
        assert_str_eq!(
            output.trim(),
            r"// Generated by bulloak

#[test]
unconstrained fn test_should_always_work() {
    // It should always work.
}

#[test]
unconstrained fn test_when_first_arg_is_smaller() {
    // It should match result.
}"
            .trim()
        );
    }

    #[test]
    fn test_generate_with_panic() {
        let tree = r"
divide
└── When divisor is zero
    └── It should panic with division by zero.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("#[test(should_fail)]"));
        assert!(output.contains("unconstrained fn test_when_divisor_is_zero()"));
    }

    #[test]
    fn test_generate_with_revert() {
        let tree = r"
divide
└── When divisor is zero
    └── It should revert with division by zero.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("#[test(should_fail)]"));
        assert!(output.contains("unconstrained fn test_when_divisor_is_zero()"));
    }

    #[test]
    fn test_dont_expect_failure_when_missing_it() {
        let tree = r"
sum
└── When invoked
    ├── It should never revert
    └── It should never panic
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(!output.contains("#[test(should_fail)]"));
    }

    #[test]
    fn test_trim_keywords_from_title() {
        let tree = r"
sum
├── It should never panic
└── When adding two numbers
    └── It should chug along
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn test_should_never_panic()"));
        assert!(
            !output.contains("unconstrained fn test_it_should_never_panic()")
        );
        assert!(!output.contains("unconstrained fn test_adding_two_numbers()"));
        assert!(
            output.contains("unconstrained fn test_when_adding_two_numbers()")
        );
    }

    #[test]
    fn test_skip_setup_hooks() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: true, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(!output.contains("unconstrained fn given_condition()"));
    }

    #[test]
    fn test_include_helpers() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn given_condition()"));
    }

    #[test]
    fn test_format_when_testcases() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn test_when_case_a()"));
        assert!(output.contains("unconstrained fn test_when_case_b()"));
    }

    #[test]
    fn test_include_assertion_comments_depth2_breadth2() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("// It should work"));
    }

    #[test]
    fn test_dont_include_modifier_with_only_one_child() {
        let tree = r"
test_root
└── Given A
    └── Given B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn given_a()"));
        assert!(!output.contains("unconstrained fn given_b()"));

        assert!(output.contains("given_a();"));
        assert!(!output.contains("given_b();"));

        assert!(output.contains("// It should work"));
    }

    #[test]
    fn test_include_modifier_with_multiple_children() {
        let tree = r"
test_root
└── Given A
    └── Given B
        ├── It should work.
        └── Given C
            └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();
        assert!(!output.contains("unconstrained fn given_c()"));

        assert_str_eq!(
            output.trim(),
            r"
// Generated by bulloak

/// Setup hook for condition
unconstrained fn given_a() {
}

/// Setup hook for condition
unconstrained fn given_b() {
}

#[test]
unconstrained fn test_given_b() {
    given_a();
    given_b();
    // It should work.
}

#[test]
unconstrained fn test_given_c() {
    given_a();
    given_b();
    // It should work.
}
        "
            .trim()
        );
    }
}
