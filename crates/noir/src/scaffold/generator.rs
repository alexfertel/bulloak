//! Noir test code generation.

use std::collections::HashSet;

use anyhow::Result;
use bulloak_syntax::{Action, Ast};

use crate::{
    config::Config,
    constants::{PANIC_KEYWORDS, TEST_PREFIX},
    utils::to_snake_case,
};

/// Generate Noir test code from an AST.
///
/// # Errors
///
/// Returns an error if code generation fails.
pub(super) fn generate(forest: &Vec<Ast>, cfg: &Config) -> Result<String> {
    let mut output = String::from("// Generated by bulloak\n\n");
    for ast in forest {
        let ast_root = match ast {
            Ast::Root(r) => r,
            _ => anyhow::bail!("Expected Root node"),
        };

        // Generate helper functions (if not skipped)
        if !cfg.skip_helpers {
            let helpers = collect_helpers(&ast_root.children);
            for helper in helpers {
                output.push_str(&generate_helper_function(&helper));
                output.push('\n');
            }
        }

        // Generate test functions
        let tests = generate_tests(&ast_root.children, &[], cfg);
        for test in tests {
            output.push_str(&test);
        }
    }

    Ok(output)
}

/// Collect all unique helper names from conditions.
fn collect_helpers(children: &[Ast]) -> Vec<String> {
    let mut helpers = HashSet::new();
    collect_helpers_recursive(children, &mut helpers);
    let mut sorted: Vec<String> = helpers.into_iter().collect();
    sorted.sort(); // Sort alphabetically for deterministic output
    sorted
}

/// Recursively collect helper names.
fn collect_helpers_recursive(children: &[Ast], helpers: &mut HashSet<String>) {
    for child in children {
        if let Ast::Condition(condition) = child {
            helpers.insert(to_snake_case(&condition.title));
            collect_helpers_recursive(&condition.children, helpers);
        }
    }
}

/// Generate a helper function.
fn generate_helper_function(name: &str) -> String {
    format!(
        "/// Helper function for condition\n\
         fn {name}() {{\n\
         }}\n"
    )
}

/// Generate test functions from AST.
fn generate_tests(
    children: &[Ast],
    parent_helpers: &[String],
    cfg: &Config,
) -> Vec<String> {
    let mut tests = Vec::new();

    for child in children {
        match child {
            Ast::Condition(condition) => {
                let mut helpers = parent_helpers.to_vec();
                if !cfg.skip_helpers {
                    helpers.push(to_snake_case(&condition.title));
                }

                // Collect all direct Action children
                let actions: Vec<&Action> = condition
                    .children
                    .iter()
                    .filter_map(|c| match c {
                        Ast::Action(a) => Some(a),
                        _ => None,
                    })
                    .collect();

                // Generate ONE test function for all actions under this
                // condition
                if !actions.is_empty() {
                    tests.push(generate_test_function(&actions, &helpers, cfg));
                }

                // Process only nested Condition children (not actions!)
                // recursively We need to collect into a Vec
                // first, then pass a slice
                let nested_conditions: Vec<_> = condition
                    .children
                    .iter()
                    .filter(|c| matches!(c, Ast::Condition(_)))
                    .collect();

                for nested_cond in nested_conditions {
                    tests.extend(generate_tests(
                        std::slice::from_ref(nested_cond),
                        &helpers,
                        cfg,
                    ));
                }
            }
            Ast::Action(action) => {
                // Root-level action
                tests.push(generate_test_function(
                    &[action],
                    parent_helpers,
                    cfg,
                ));
            }
            _ => {}
        }
    }

    tests
}

/// Generate a single test function for one or more actions.
fn generate_test_function(
    actions: &[&Action],
    helpers: &[String],
    cfg: &Config,
) -> String {
    // Determine test name
    let test_name = if helpers.is_empty() {
        // Root level: test_{action_name}
        format!("{}_{}", TEST_PREFIX, to_snake_case(&actions[0].title))
    } else {
        // Under condition: test_when_{last_helper}
        format!("{}_when_{}", TEST_PREFIX, helpers.last().unwrap())
    };

    // Check if any action contains panic keywords
    let has_panic =
        actions.iter().any(|action| has_panic_keyword(&action.title));

    // Generate attribute
    let attr = if has_panic { "#[test(should_fail)]\n" } else { "#[test]\n" };

    // Generate function body
    let mut body = String::new();

    // Call helpers in order
    if !cfg.skip_helpers {
        for helper in helpers {
            use std::fmt::Write;
            let _ = writeln!(body, "    {helper}();");
        }
    }

    // Add action comments
    for action in actions {
        let comment =
            format_action_comment(&action.title, cfg.format_descriptions);
        use std::fmt::Write;
        let _ = writeln!(body, "    // {comment}");
    }

    format!("{attr}unconstrained fn {test_name}() {{\n{body}}}\n\n")
}

/// Format an action comment.
fn format_action_comment(title: &str, format_descriptions: bool) -> String {
    if format_descriptions {
        // Capitalize first letter
        let mut chars = title.chars();
        match chars.next() {
            Some(f) => f.to_uppercase().collect::<String>() + chars.as_str(),
            None => String::new(),
        }
    } else {
        title.to_string()
    }
}

/// Check if a title contains panic keywords.
fn has_panic_keyword(title: &str) -> bool {
    let lower = title.to_lowercase();
    PANIC_KEYWORDS.iter().any(|keyword| lower.contains(keyword))
}

#[cfg(test)]
mod tests {
    use bulloak_syntax::parse;

    use super::*;

    #[test]
    fn test_generate_basic() {
        let tree = r"
hash_pair
├── It should always work.
└── When first arg is smaller
    └── It should match result.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("// Generated by bulloak"));
        assert!(output.contains("fn first_arg_is_smaller()"));
        assert!(output
            .contains("#[test]\nunconstrained fn test_should_always_work()"));
        assert!(output.contains(
            "#[test]\nunconstrained fn test_when_first_arg_is_smaller()"
        ));
    }

    #[test]
    fn test_generate_with_panic() {
        let tree = r"
divide
└── When divisor is zero
    └── It should panic with division by zero.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("#[test(should_fail)]"));
        assert!(output.contains("unconstrained fn test_when_divisor_is_zero()"));
    }

    #[test]
    fn test_skip_helpers() {
        let tree = r"
test_root
└── When condition
    └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_helpers: true, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(!output.contains("fn condition()"));
        assert!(output.contains("#[test]\nunconstrained fn test_should_work()"));
    }
}
