//! Noir test code generation.

use std::collections::HashSet;

use anyhow::Result;
use bulloak_syntax::{Action, Ast};

use crate::{
    config::Config,
    constants::{PANIC_KEYWORDS, TEST_PREFIX},
    utils::to_snake_case,
};

enum ExpectedTests {
    Root(Root),
    SetupHook(SetupHook),
    TestFunction(TestFunction),
    // TODO: Module
}
trait Scaffoldable {
    fn scaffold(&self, generate_setup_hooks: bool) -> String;
}

struct Root {
    // TODO: Modules?
    setup_hooks: Vec<SetupHook>,
    tests: Vec<TestFunction>,
}
/// Used for both definition and invocation
#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Debug)]
struct SetupHook {
    name: String,
}

#[derive(Debug)]
struct TestFunction {
    name: String,
    expect_fail: bool,
    setup_hooks: Vec<SetupHook>,
    actions: Vec<String>,
}

impl Scaffoldable for Root {
    fn scaffold(&self, generate_setup_hooks: bool) -> String {
        let mut output = String::from("// Generated by bulloak\n\n");
        if generate_setup_hooks {
            for hook in &self.setup_hooks {
                output.push_str(&hook.scaffold(true));
            }
        }
        for test in &self.tests {
            output.push_str(&test.scaffold(generate_setup_hooks));
            output.push_str("\n");
        }
        output
    }
}

impl Scaffoldable for TestFunction {
    fn scaffold(&self, generate_setup_hooks: bool) -> String {
        let mut output = String::from("");
        output.push_str(if self.expect_fail {
            "#[test(should_fail)]\n"
        } else {
            "#[test]\n"
        });
        output.push_str(&format!("unconstrained fn {}() {{\n", self.name));
        if generate_setup_hooks {
            for hook in &self.setup_hooks {
                output.push_str(&format!("    {}();\n", hook.name));
            }
        }
        for action in &self.actions {
            output.push_str(&format!("    // {}\n", action));
        }
        output.push_str("}\n");
        output
    }
}
impl Scaffoldable for SetupHook {
    fn scaffold(&self, generate_setup_hooks: bool) -> String {
        assert!(generate_setup_hooks);
        format!(
            "/// Setup hook for condition\n\
         unconstrained fn {}() {{\n\
         }}\n\n",
            self.name
        )
    }
}

impl Scaffoldable for ExpectedTests {
    fn scaffold(&self, generate_setup_hooks: bool) -> String {
        match self {
            Self::Root(r) => r.scaffold(generate_setup_hooks),
            Self::SetupHook(h) => h.scaffold(generate_setup_hooks),
            Self::TestFunction(t) => t.scaffold(generate_setup_hooks),
        }
    }
}

/// Generate Noir test code from an AST.
///
/// # Errors
///
/// Returns an error if code generation fails.
pub(super) fn generate(forest: &Vec<Ast>, cfg: &Config) -> Result<String> {
    // Generate test functions
    let tests = collect_tests(forest, &[]);
    let setup_hooks = collect_helpers(forest);
    let root = Root { setup_hooks, tests };

    Ok(root.scaffold(!cfg.skip_setup_hooks))
}

/// Collect all unique helper names from conditions.
fn collect_helpers(children: &[Ast]) -> Vec<SetupHook> {
    let mut helpers = HashSet::new();
    collect_helpers_recursive(children, &mut helpers);
    let mut sorted: Vec<SetupHook> = helpers.into_iter().collect();
    sorted.sort();
    sorted
}

/// Recursively collect helper names.
fn collect_helpers_recursive(
    children: &[Ast],
    helpers: &mut HashSet<SetupHook>,
) {
    for child in children {
        match child {
            Ast::Condition(condition) => {
                // only produce helpers for a branch if any of its children is also a branch, meaning
                // there's a potential need to reuse them
                if condition.children.iter().any(|c| match c {
                    Ast::Condition(_) => true,
                    _ => false,
                }) {
                    helpers.insert(SetupHook {
                        name: to_snake_case(&condition.title),
                    });
                }
                collect_helpers_recursive(&condition.children, helpers);
            }
            Ast::Root(root) => {
                collect_helpers_recursive(&root.children, helpers);
            }
            _ => {}
        }
    }
}

fn collect_tests(
    children: &[Ast],
    parent_helpers: &[SetupHook],
) -> Vec<TestFunction> {
    let mut tests = Vec::new();

    for child in children {
        match child {
            Ast::Condition(condition) => {
                let mut helpers = parent_helpers.to_vec();
                helpers
                    .push(SetupHook { name: to_snake_case(&condition.title) });
                // Cllect all direct Action children
                let actions: Vec<&Action> = condition
                    .children
                    .iter()
                    .filter_map(|c| match c {
                        Ast::Action(a) => Some(a),
                        _ => None,
                    })
                    .collect();

                // Generate ONE test function for all actions under this
                // condition
                if !actions.is_empty() {
                    // use the last helper only if the action has silbings
                    // that merit re-using it
                    tests.push(generate_test_function(
                        &actions,
                        &helpers,
                        condition.children.len() > 1,
                    ));
                }

                // Process only nested Condition children (not actions!)
                // recursively We need to collect into a Vec
                // first, then pass a slice
                let nested_conditions: Vec<_> = condition
                    .children
                    .iter()
                    .filter(|c| matches!(c, Ast::Condition(_)))
                    .collect();

                for nested_cond in nested_conditions {
                    tests.extend(collect_tests(
                        std::slice::from_ref(nested_cond),
                        &helpers,
                    ));
                }
            }
            Ast::Action(action) => {
                // Root-level action
                tests.push(generate_test_function(
                    &[action],
                    &parent_helpers.to_vec(),
                    false,
                ));
            }
            Ast::Root(root) => {
                tests.extend(collect_tests(&root.children, &[]));
            }
            _ => {}
        }
    }

    tests
}

/// Generate a single test function for one or more actions.
fn generate_test_function(
    actions: &[&Action],
    helpers: &Vec<SetupHook>,
    use_last_helper: bool,
) -> TestFunction {
    // Determine test name
    let name = if helpers.is_empty() {
        let title = &actions[0].title;
        // trim 'it' from first-level assertions (not very frequent, but necessary for consistency
        // with foundry backend)
        let title = title
            .strip_prefix("it ")
            .or_else(|| title.strip_prefix("It "))
            .unwrap_or(title);
        // Root level: test_{action_name}
        format!("{}_{}", TEST_PREFIX, to_snake_case(title))
    } else {
        // Under condition: test_{last_helper}
        format!("{}_{}", TEST_PREFIX, &helpers.last().unwrap().name)
    };

    let expect_fail =
        actions.iter().any(|action| has_panic_keyword(&action.title));

    let setup_hooks: Vec<SetupHook> = helpers
        .iter()
        .filter(|x| *x != helpers.iter().last().unwrap() || use_last_helper)
        .cloned()
        .collect();

    TestFunction {
        name,
        expect_fail,
        setup_hooks,
        // TODO: c'mon the action array is right there...
        actions: actions.iter().map(|x| x.title.clone()).collect(),
    }
}

/// Check if a title contains panic keywords.
fn has_panic_keyword(title: &str) -> bool {
    let lower = title.to_lowercase();
    PANIC_KEYWORDS.iter().any(|keyword| lower.contains(keyword))
}

#[cfg(test)]
mod tests {
    use bulloak_syntax::parse;
    use pretty_assertions::assert_str_eq;

    use super::*;

    #[test]
    fn test_generate_basic() {
        let tree = r"
hash_pair
├── It should always work.
└── When first arg is smaller
    └── It should match result.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("// Generated by bulloak"));
        // do not generate helpers for trivial levels of nesting
        assert!(!output.contains("fn first_arg_is_smaller()"));
        assert!(!output.contains("    when_first_arg_is_smaller()"));
        assert!(output
            .contains("#[test]\nunconstrained fn test_should_always_work()"));
        assert!(output.contains(
            "#[test]\nunconstrained fn test_when_first_arg_is_smaller()"
        ));
        assert_str_eq!(
            output.trim(),
            r"// Generated by bulloak

#[test]
unconstrained fn test_should_always_work() {
    // It should always work.
}

#[test]
unconstrained fn test_when_first_arg_is_smaller() {
    // It should match result.
}"
            .trim()
        );
    }

    #[test]
    fn test_generate_with_panic() {
        let tree = r"
divide
└── When divisor is zero
    └── It should panic with division by zero.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("#[test(should_fail)]"));
        assert!(output.contains("unconstrained fn test_when_divisor_is_zero()"));
    }

    #[test]
    fn test_generate_with_revert() {
        let tree = r"
divide
└── When divisor is zero
    └── It should revert with division by zero.
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("#[test(should_fail)]"));
        assert!(output.contains("unconstrained fn test_when_divisor_is_zero()"));
    }

    #[test]
    fn test_dont_expect_failure_when_missing_it() {
        let tree = r"
sum
└── When invoked
    ├── It should never revert
    └── It should never panic
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(!output.contains("#[test(should_fail)]"));
    }

    #[test]
    fn test_trim_keywords_from_title() {
        let tree = r"
sum
├── It should never panic
└── When adding two numbers
    └── It should chug along
";

        let ast = parse(tree).unwrap();
        let cfg = Config::default();
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn test_should_never_panic()"));
        assert!(
            !output.contains("unconstrained fn test_it_should_never_panic()")
        );
        assert!(!output.contains("unconstrained fn test_adding_two_numbers()"));
        assert!(
            output.contains("unconstrained fn test_when_adding_two_numbers()")
        );
    }

    #[test]
    fn test_skip_setup_hooks() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: true, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(!output.contains("unconstrained fn given_condition()"));
    }

    #[test]
    fn test_include_helpers() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn given_condition()"));
    }

    #[test]
    fn test_format_when_testcases() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn test_when_case_a()"));
        assert!(output.contains("unconstrained fn test_when_case_b()"));
    }

    #[test]
    fn test_include_assertion_comments_depth2_breadth2() {
        let tree = r"
test_root
└── Given condition
    ├── When case A
    │   └── It should work.
    └── When case B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("// It should work"));
    }

    #[test]
    fn test_dont_include_modifier_with_only_one_child() {
        let tree = r"
test_root
└── Given A
    └── Given B
        └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();

        assert!(output.contains("unconstrained fn given_a()"));
        assert!(!output.contains("unconstrained fn given_b()"));

        assert!(output.contains("given_a();"));
        assert!(!output.contains("given_b();"));

        assert!(output.contains("// It should work"));
    }

    #[test]
    fn test_include_modifier_with_multiple_children() {
        let tree = r"
test_root
└── Given A
    └── Given B
        ├── It should work.
        └── Given C
            └── It should work.
";

        let ast = parse(tree).unwrap();
        let cfg = Config { skip_setup_hooks: false, ..Default::default() };
        let output = generate(&ast, &cfg).unwrap();
        assert!(!output.contains("unconstrained fn given_c()"));

        assert_str_eq!(
            output.trim(),
            r"
// Generated by bulloak

/// Setup hook for condition
unconstrained fn given_a() {
}

/// Setup hook for condition
unconstrained fn given_b() {
}

#[test]
unconstrained fn test_given_b() {
    given_a();
    given_b();
    // It should work.
}

#[test]
unconstrained fn test_given_c() {
    given_a();
    given_b();
    // It should work.
}
        "
            .trim()
        );
    }
}
