pub(crate) mod generator;
pub(crate) mod scaffoldable;
use std::path::PathBuf;

use crate::utils::get_module_name;

use super::config::Config;
use anyhow::{bail, Result};
use bulloak_syntax::parse;
use generator::generate;

/// Generates aztec-noir code from a `.tree` file. Has a uniform interface with the default
/// solidity backend.
/// TODO: should we define a Backend trait?
pub fn scaffold(
    text: &str,
    treefile: &PathBuf,
    cfg: &Config,
) -> Result<String> {
    let forest = parse(text)?;

    match get_module_name(&forest) {
        None => {} // empty tree
        // tree has only one root module
        Some(Ok(actual)) => {
            let expected = treefile
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or_else(|| panic!("this condition should be unreachable, as the file was successfully read once already."));

            if actual != expected {
                bail!(
                    "module name mismatch: expected '{}', found '{}'",
                    expected,
                    actual
                );
            }
        }
        Some(Err((expected, second))) => {
            bail!(
                "module name mismatch: expected '{}', found '{}'",
                expected,
                second
            );
        }
    }
    generate(&forest, cfg)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn single_leaf() {
        let file_contents = r"
Module::Function
└── When thing exists
    └── it should work"
            .trim();
        let output = scaffold(
            &file_contents.to_string(),
            &PathBuf::from("Module.tree"),
            &Config::default(),
        )
        .unwrap();
        let expected = r"
// Generated by bulloak

#[test]
unconstrained fn test_when_thing_exists() {
    // it should work
}";
        assert_eq!(output.trim(), expected.trim());
    }

    #[test]
    fn two_roots() {
        let file_contents = r"
Module::Function
└── When thing exists
    └── it should work

Module::OtherFunction
└── When thing exists
    └── it should work";
        let output = scaffold(
            &file_contents.to_string(),
            &PathBuf::from("Module.tree"),
            &Config::default(),
        )
        .unwrap();
        let expected = r"
// Generated by bulloak


mod Function {
    #[test]
    unconstrained fn test_when_thing_exists() {
        // it should work
    }

}

mod OtherFunction {
    #[test]
    unconstrained fn test_when_thing_exists() {
        // it should work
    }

}
";
        assert_eq!(output.trim(), expected.trim());
    }

    #[test]
    fn two_roots_repeated_submodule() {
        let file_contents = r"
Module::Function
└── When thing exists
    └── it should work

Module::Function
└── When thing exists
    └── it should work";
        let output = scaffold(
            &file_contents.to_string(),
            &PathBuf::from("Module.tree"),
            &Config::default(),
        );
        assert!(output.is_err_and(|err| err
            .to_string()
            .contains("submodule Function has more than one definition")));
    }

    #[test]
    fn two_roots_no_submodule() {
        let file_contents = r"
Module
└── When thing exists
    └── it should work

Module
└── When second thing exists
    └── it should work";
        let output = scaffold(
            &file_contents.to_string(),
            &PathBuf::from("Module.tree"),
            &Config::default(),
        );
        assert!(output.is_err_and(|err| err.to_string().contains(r#"an error occurred while parsing the tree: separator missing at tree root #1 "Module". Expected to find `::` between the contract name and the function name when multiple roots exist"#)));
    }
}
